# Model demonstrations

# Simple model with fields
const Point = model {
  x: float
  y: float
}

var p1 = Point(3, 4)
println("Point:", p1)
println("x:", p1.x)
println("y:", p1.y)

# Model with methods
const Rectangle = model {
  width: float
  height: float

  area = function() {
    return this.width * this.height
  }

  perimeter = function() {
    return 2 * (this.width + this.height)
  }
}

var rect = Rectangle(5, 3)
println("\nRectangle:", rect)
println("Width:", rect.width)
println("Height:", rect.height)
println("Area:", rect.area())
println("Perimeter:", rect.perimeter())

# Nested models
const Circle = model {
  center: Point
  radius: float

  area = function() {
    return 3.14159 * this.radius * this.radius
  }
}

var center = Point(0, 0)
var circle = Circle(center, 5)
println("\nCircle:", circle)
println("Center x:", circle.center.x)
println("Center y:", circle.center.y)
println("Radius:", circle.radius)
println("Area:", circle.area())

# Multiple constructors
const Vector = model {
  x: float
  y: float

  # Constructor from single value (creates Vector(v, v))
  constructor = function(v: float) {
    return Vector(v, v)
  }

  # Constructor with no args (creates zero vector)
  constructor = function() {
    return Vector(0, 0)
  }

  dot = function(other: Vector) {
    return this.x * other.x + this.y * other.y
  }
}

var v1 = Vector(3, 4)
var v2 = Vector(5)
var v3 = Vector()
println("\nMultiple constructors:")
println("Vector(3, 4):", v1)
println("Vector(5):", v2)
println("Vector():", v3)

# Type checking with 'is' operator
println("\nType checking:")
println("p1 is Point:", p1 is Point)
println("rect is Point:", rect is Point)
println("rect is Rectangle:", rect is Rectangle)
println("v1 is Vector:", v1 is Vector)

# Built-in type checking
var num = 42
var text = "hello"
println("\nBuilt-in type checking:")
println("num is integer:", num is integer)
println("num is string:", num is string)
println("text is string:", text is string)
println("text is integer:", text is integer)

# Error handling with built-in Error model
const safeDivide = function(a: float, b: float) {
  if b == 0 {
    return Error("division by zero")
  }
  return a / b
}

var result1 = safeDivide(10, 2)
var result2 = safeDivide(10, 0)

println("\nError handling:")
println("safeDivide(10, 2):", result1)
println("safeDivide(10, 0):", result2)

if result2 is Error {
  println("Caught error:", result2.message)
}
